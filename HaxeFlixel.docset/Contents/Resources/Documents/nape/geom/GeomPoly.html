<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../../jquery-1.9.1.min.js"></script><script src="../../bootstrap/js/bootstrap.min.js"></script><script src="../../bootstrap/js/bootstrap-select.min.js"></script><link href="../../styles.css" rel="stylesheet"/><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["types"]};</script><script type="text/javascript" src="../..//nav.js"></script><script type="text/javascript" src="../..//index.js"></script><link rel="icon" href="../..//favicon.ico" type="image/x-icon"></link><title>nape.geom.GeomPoly - HaxeFlixel API</title></head><body><nav><div class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="http://www.haxeflixel.com/" class="navbar-brand"><img src="http://www.haxeflixel.com/images/haxeflixel-header.png" alt="HaxeFlixel"/></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="http://www.haxeflixel.com/demos">Demos</a></li><li><a href="http://www.haxeflixel.com/showcase">Showcase</a></li><li><a href="http://www.haxeflixel.com/blog">Blog</a></li><li><a href="http://www.haxeflixel.com/documentation">Docs</a></li><li class="active"><a href=".">API</a></li><li><a href="http://www.haxeflixel.com/forum">Forum</a></li></ul></div></div></div></nav><div class="container navbar-offset">        <div class="row-fluid container-main">            <div class="span3">              <div class="well sidebar-nav">                <form class="form-search" id="searchForm">                  <div class="input-prepend input-block-level">                    <span class="add-on"><i class="icon-search"></i></span>                    <input id="search" type="text" placeholder="Search" autocomplete="off"/>                  </div>                </form></div>              <div class="well sidebar-nav">                <div id="nav"></div>              </div>            </div>            <div class="span9"><div class="page-header"><span class="viewsource"><a href="https://github.com/deltaluca/nape/tree/master/cx-src/nape/geom/GeomPoly.cx">View source</a></span><h4><small>package nape.geom</small></h4><h1><small>class </small>GeomPoly</h1></div><div class="body"><div class="doc doc-main"><div class="indent"><p>Polygon class with various geometric methods
<br/><br/>
This class represents a general Polygon, rather than the Polygon class
which is physics shape.
<br/><br/>
Internally this polygon is stored as a circularly linked list of special
vertex types that are exposed via a Vec2 that is lazily constructed whenever
necessary to the API.</p></div></div><h3 class="section">Constructor</h3><div class="fields"><div class="field "><a name="new"></a><h3><p><code><a href="#new"><span class="identifier">new</span></a>(<span style="white-space:nowrap">?vertices:<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../Dynamic.html">Dynamic</a></span>)</code></p></h3><div class="doc"><p>Create a new GeomPoly polygon.
<br/><br/>
The vertices argument is typed Dynamic (* in AS3), and is permitted
to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
<br/><br/>
The input will be used to initialise the vertices of the polygon with
the head of the polygon pointing to the first vertex in input with vertices
inserted in forward order.
<br/><br/>
You should use the static 'get' method in preference to make use of object pool.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>vertices</code> <p>Vertex data to initialise polygon, or null for empty polygon.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>New GeomPoly representing input vertex data.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If input data is not of an expected Type.</p></div></div></div></div><h3 class="section">Variables</h3><div class="fields"><div class="field "><a name="zpp_disp"></a><h3><p><code><a href="#zpp_disp"><span class="identifier">zpp_disp</span></a>:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="field "><a name="zpp_inner"></a><h3><p><code><a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<span class="type">ZPP_GeomPoly</span><span> = null</span></code></p></h3><div class="doc"><p>@private</p></div></div><div class="field "><a name="zpp_pool"></a><h3><p><code><a href="#zpp_pool"><span class="identifier">zpp_pool</span></a>:<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a><span> = null</span></code></p></h3><div class="doc"><p>@private</p></div></div></div><h3 class="section">Methods</h3><div class="fields"><div class="field "><a name="area"></a><h3><p><code><a href="#area"><span class="identifier">area</span></a>():<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Compute area of weakly-simple polygon.
<br/><br/>
For complex polygons, this function will return an underestimate
to the true area.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The area of the polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="backwardsIterator"></a><h3><p><code><span class="label">inline</span> <a href="#backwardsIterator"><span class="identifier">backwardsIterator</span></a>():<a class="type" title="Haxe compatible iterator over vertices of GeomPoly." href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></code></p></h3><div class="doc"><p>Haxe iterator over vertices of polygon.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Haxe iterator over the vertices of the polygon.
Iterating in a backwards direction.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="bottom"></a><h3><p><code><a href="#bottom"><span class="identifier">bottom</span></a>():<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find bottom most vertex of polygon.
<br/><br/>
If there is more than one such vertex then the result is indeterminate.
<br/><br/>
The Vec2 returned is intrinsically tied to the inner vertex like that
returned by current(). This method will not alter the current vertex.
This Vec2 is not able to be disposed of.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Vec2 representing the bottom most vertex.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="bounds"></a><h3><p><code><a href="#bounds"><span class="identifier">bounds</span></a>():<a class="type" title="Axis Aligned Bounding Box (AABB)  Note that in many cases of an AABB object being returned by a Nape function the AABB object will be marked internally as an 'immutable' AABB." href="../../nape/geom/AABB.html">AABB</a></code></p></h3><div class="doc"><p>Determine bounds of polygon.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new AABB representing bounds of polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="clear"></a><h3><p><code><a href="#clear"><span class="identifier">clear</span></a>():<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Clear all vertices from polygon.
<br/><br/>
All of the vertices will be released to the global object pool.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="contains"></a><h3><p><code><a href="#contains"><span class="identifier">contains</span></a>(<span style="white-space:nowrap">point:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if point is contained in polygon.
<br/><br/>
Polygon containment is performed with a ray cast through polygon
from the vertex and counting the number of intersections. In this
way containment will be defined for self-intersecting polygons based
on how such a polygon would be rendered with areas of self-intersection
treat as being 'outside' the polygon.
<br/><br/>
This algorithm operates in O(n) time.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>point</code> <p>The point to test for containment.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if point is contained in the polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If point is null or has been disposed.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="convexDecomposition"></a><h3><p><code><a href="#convexDecomposition"><span class="identifier">convexDecomposition</span></a>(<span style="white-space:nowrap">delaunay:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></span>):<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of weakly-simple polygon into convex components.
<br/><br/>
This algorithm 'should' be 100% robust and has been well test on for
example, the output of the Marching Squars utility which produces many
degenerate cases of weakly-simple polygons that have not yet broken this
algorithm!.
<br/><br/>
This algorithm operates in O(n.log(n)) time and will produce no more than
4 times the number of convex poylgons in a minimal decomposition in the
worst case scenario.
<br/><br/>
Vertices may be stripped from the polygon that are found to not be
necessary as part of making this algorithm robust.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>delaunay</code> <p>This algorithm first performs a triangulation, if this field
is true, then this triangulation will be made delaunay and may
produce better convex polygons resultanly (default false).</p></div><div class="indent inline-content"><code>output</code> <p>If supplied, polygons will be appended to this list via 'add'
instead of a new list being constructed.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Nape list of GeomPoly's defining the decomposition.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is degenerate.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="copy"></a><h3><p><code><a href="#copy"><span class="identifier">copy</span></a>():<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Copy this polygon.
<br/><br/>
The copy will have its vertices in the same order as 'this' polygon.
It will also have its current vertex at head, as the same vertex
this polygon has.
<br/><br/>
This polygon will not be modified in any way.
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly2 = poly.copy();</p>
<p>poly2 := -> A' &lt;-> B' &lt;-> C' &lt;-> D' &lt;-> E' &lt;-</p>
<pre><code>             (head)
</code></pre>
<p></pre></p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The new GeomPoly representing the copy.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="current"></a><h3><p><code><span class="label">inline</span> <a href="#current"><span class="identifier">current</span></a>():<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Current vertex at head of polygon.
<br/><br/>
The current vertex will not be changed by this access.
<br/><br/>
This function returns a Vec2 which will be intrinsically tied
to the values of the internal vertex so that modifications to
this Vec2 will be reflected in the vertex of the polygon.
<br/><br/>
If invoked again with the head of the polygon pointing to the
same vertex, then the same Vec2 will be returned; this Vec2 is
not able to be disposed of.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Vec2 representing the current vertex of polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="cut"></a><h3><p><code><a href="#cut"><span class="identifier">cut</span></a>(<span style="white-space:nowrap">start:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>, <span style="white-space:nowrap">end:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>, <span style="white-space:nowrap">boundedStart:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">boundedEnd:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></span>):<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Cut simple polygon with line.
<br/><br/>
The result of this operation will be a list of new GeomPoly representing
the connected regions of the polygon after an imaginary cut is made.
<pre>
(Result of cut assuming
boundedStart = true)       <em>
/&#92;    _             /&#92;   / &#92;
/  &#92;  / &#92;           /  &#92; '---'
/ o--&#92;/---&#92;-->  =>  /    &#92;,---,
&#92;<strong></strong><strong></strong></em>/         &#92;<strong></strong><strong></strong>_/
</pre>
This algorithm runs in average case O(n.log(n)) time and worst case O(n^2).
For convex polygons, this algorithm runs in guaranteed O(n) time.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>start</code> <p>The start point for line segment</p></div><div class="indent inline-content"><code>end</code> <p>The end point for line segment.</p></div><div class="indent inline-content"><code>boundedStart</code> <p>If true, then the cut will not extend
beyond the start of the line segment.
(default false)</p></div><div class="indent inline-content"><code>boundedEnd</code> <p>If true, then the cut will not extend
beyond the end of the line segment.
(default false)</p></div><div class="indent inline-content"><code>output</code> <p>A GeomPolyList to append results to if supplied,
otherwise a new list is created (default null)</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of GeomPoly representing the result of the cut.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is not simple.</p></div><div class="indent inline-content"><code>#</code> <p>If start or end Vec2 are null or disposed of.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="dispose"></a><h3><p><code><a href="#dispose"><span class="identifier">dispose</span></a>():<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Release this GeomPoly to global object pool.
<br/><br/>
Once disposed this GeomPoly will be accessible to Nape internals for re-allocation
and should not be touched (Good practice would be to set any references to this
GeomPoly to null to help ensure this).
<br/><br/>
In debug mode, should you attempt to access this GeomPoly after disposal
and the GeomPoly is still in the object pool, you will be given an Error.
The object pool operates on a First-In-Last-Out principal in debug mode to help
catch these sort of errors.</p><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has already been disposed.</p></div></div></div><div class="field "><a name="empty"></a><h3><p><code><span class="label">inline</span> <a href="#empty"><span class="identifier">empty</span></a>():<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is empty.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if polygon is empty.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="erase"></a><h3><p><code><a href="#erase"><span class="identifier">erase</span></a>(<span style="white-space:nowrap">count:<a class="type" title="The standard Int type." href="../../Int.html">Int</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Erase count number of elements
<br/><br/>
For positive values of count, this is equivalent to successive
unshift operations.
<br/><br/>
For negative values of count, this is equivalent to successive
pop operations.
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-> F &lt;-> G &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.erase(2);</p>
<p>poly := -> A &lt;-> D &lt;-> E &lt;-> F &lt;-> G &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.erase(-3);</p>
<p>poly := -> E &lt;-> F &lt;-</p>
<pre><code>           (head)
</code></pre>
<p></pre>
In this case that the specified number of elements to erase is
greater than the size of the polygon, the method will simply
terminate with the polygon being empty.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>count</code> <p>The number of vertices to erase, with sign indicating
the direction for erasing.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="forwardIterator"></a><h3><p><code><span class="label">inline</span> <a href="#forwardIterator"><span class="identifier">forwardIterator</span></a>():<a class="type" title="Haxe compatible iterator over vertices of GeomPoly." href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></code></p></h3><div class="doc"><p>Haxe iterator over vertices of polygon.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Haxe iterator over the vertices of the polygon.
Iterating in a forward direction.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="inflate"></a><h3><p><code><a href="#inflate"><span class="identifier">inflate</span></a>(<span style="white-space:nowrap">inflation:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Inflate/Deflate polygon.
<br/><br/>
This algorithm does not attempt to deal with any self-intersections which may
result from the process. Gaps are joined with a miter joint.
<br/><br/>
This algorithm will work for self-intersecting polygons, though the results
may not be what you expect; some parts will be inflated, and some deflated
depending on the local winding. You should probably avoid using this on
self-intersecting polygons.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>inflation</code> <p>The number of pixels to inflate polygon by. To deflate
use a negative value.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The inflated polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="isClockwise"></a><h3><p><code><span class="label">inline</span> <a href="#isClockwise"><span class="identifier">isClockwise</span></a>():<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is clockwise wound.
<br/><br/>
This is equivalent to <code>poly.winding() == Winding.CLOCKWISE</code>.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if polygon is clockwise wound.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="isConvex"></a><h3><p><code><a href="#isConvex"><span class="identifier">isConvex</span></a>():<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if weakly-simple polygon is convex.
<br/><br/>
This algorithm assumes that the polygon is weakly-simple. Otherwise it may
fail (It is very easy to construct a self intersecting polygon which
will return True for isConvex()).
<br/><br/>
You may wish to instead use <code>isSimple() &amp;&amp; isConvex()</code> if
you cannot be sure of the polygon being simple, noting that this will
of course return false in the case of a weakly-simple polygon.
<pre></p>
<hr />
<p>|     |
|     |  &lt;-- convex
|<strong></strong>/
<strong>
|  &#92;</strong>_
|     /  &lt;-- concave
|<strong></strong>/
</pre>
This algorithm operates in O(n) time.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if polygon is found to be convex.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="isDegenerate"></a><h3><p><code><span class="label">inline</span> <a href="#isDegenerate"><span class="identifier">isDegenerate</span></a>():<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if weakly-simple polygon is degenerate.
<br/><br/>
Degeneracy is determined by having a zero area, if polygon is complex,
then this function may report degeneracy erroneously.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if polygon is degenerate.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="isMonotone"></a><h3><p><code><span class="label">inline</span> <a href="#isMonotone"><span class="identifier">isMonotone</span></a>():<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is y-monotone.
<br/><br/>
To be classed as y-monotone, the polygon must be such that any horizontal
line intersects the polygon in at most 2 intersections.
<pre></p>
<hr />
<p>|   |
|   |  &lt;-- y-monotone
|___|</p>
<p>|&#92;
| &#92;/|  &lt;-- not y-monotone, offending vertex at bottom of the V.
|___|
</pre>
This algorithm operates in O(n) time.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if polygon is y-monotone.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="isSimple"></a><h3><p><code><span class="label">inline</span> <a href="#isSimple"><span class="identifier">isSimple</span></a>():<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Determine if polygon is strictly simple.
<br/><br/>
By strict simplicity, we refer to not permitting 'glancing'
self intersections (where boundary of polygon 'touches' but does not
pass through another area of the polygon's boundary). This property
is instead referred to as being 'weakly simple' for which there is no
easy test!
<pre></p>
<hr /><table><thead><th align="null">__</th><th align="null">&lt;-- strictly simple polygon.</th></thead><tbody></tbody></table>
<p>|   &#92; &#92;_|
&#92;__/</p>
<hr /><table><thead><th></th><th></th></thead><tbody></tbody></table>
<p>&#92;<strong></strong>_/</p>
<hr />
<p>| <strong>/
X_  </strong>   &lt;-- complex polygon.
|  &#92;/  &#92;
&#92;<strong>/&#92;</strong>|
</pre>
This algorithm operates in O(n.log(n)) time.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if polygon is strictly simple.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="iterator"></a><h3><p><code><span class="label">inline</span> <a href="#iterator"><span class="identifier">iterator</span></a>():<a class="type" title="Haxe compatible iterator over vertices of GeomPoly." href="../../nape/geom/GeomVertexIterator.html">GeomVertexIterator</a></code></p></h3><div class="doc"><p>Haxe iterator over vertices of polygon.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Haxe iterator over the vertices of the polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="left"></a><h3><p><code><a href="#left"><span class="identifier">left</span></a>():<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find left most vertex of polygon.
<br/><br/>
If there is more than one such vertex then the result is indeterminate.
<br/><br/>
The Vec2 returned is intrinsically tied to the inner vertex like that
returned by current(). This method will not alter the current vertex.
This Vec2 is not able to be disposed of.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Vec2 representing the left most vertex.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="monotoneDecomposition"></a><h3><p><code><a href="#monotoneDecomposition"><span class="identifier">monotoneDecomposition</span></a>(<span style="white-space:nowrap">?output:<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></span>):<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of weakly-simple polygon into monotone components.
<br/><br/>
This algorithm 'should' be 100% robust and has been well tested on for
example, the output of the Marching Squares utility which produces many
degenerate cases of weakly-simple polygons that have not yet broken this
algorithm!.
<br/><br/>
This algorithm operates in O(n.log(n)) time and may strip vertices from
the polygon in degenerate cases where vertex is not needed to define the
polygon.
<br/><br/>
This algorithm is an improved version of the one presented in: Mark de
Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf.
Computational Geometry: Algorithms and Applications. Springer-Verlag,
Berlin, 1997.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>output</code> <p>If supplied, polygons will be appended to this list via 'add'
instead of a new list being constructed.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Nape list of GeomPoly's defining the decomposition.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is degenerate.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="pop"></a><h3><p><code><a href="#pop"><span class="identifier">pop</span></a>():<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Pop vertex from polygon.
<br/><br/>
Pop the current vertex at head of polygon, retreating the 'current'
vertex to point to the previous vertex in polygon. This inner vertex
will be released to the global object pool.
<br/><br/>
In this way a pop which follows a push will act to reset the push.
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.pop();</p>
<p>poly := -> A &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>     (head)
</code></pre>
<p></pre></p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="push"></a><h3><p><code><a href="#push"><span class="identifier">push</span></a>(<span style="white-space:nowrap">vertex:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Push vertex to polygon.
<br/><br/>
A vertex will be allocated from a global object pool, and initialised
with the values of the given Vec2.
<br/><br/>
This vertex will be inserted after the current head, and the head
advanced to the newly inserted vertex, in this way successive pushes
will insert elements in order.
<br/><br/>
Note that the Vec2 supplied as argument is only used to initialise the
inner Vertex.
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.push(X);</p>
<p>poly := -> A &lt;-> B &lt;-> X &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>                 (head)
</code></pre>
<p></pre></p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>vertex</code> <p>The Vec2 to be used in initialising the inner vertex.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If Vec2 is null, or has been disposed.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="right"></a><h3><p><code><a href="#right"><span class="identifier">right</span></a>():<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find right most vertex of polygon.
<br/><br/>
If there is more than one such vertex then the result is indeterminate.
<br/><br/>
The Vec2 returned is intrinsically tied to the inner vertex like that
returned by current(). This method will not alter the current vertex.
This Vec2 is not able to be disposed of.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Vec2 representing the right most vertex.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="shift"></a><h3><p><code><a href="#shift"><span class="identifier">shift</span></a>():<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Shift vertex from polygon.
<br/><br/>
Shift the current vertex at head of polygon, advancing the 'current'
vertex to point to the next vertex in polygon. This inner vertex
will be released to the global object pool.
<br/><br/>
In this way a shift which follows an unshift will act to reset the
unshift operation.
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.shift();</p>
<p>poly := -> A &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p></pre></p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="simpleDecomposition"></a><h3><p><code><a href="#simpleDecomposition"><span class="identifier">simpleDecomposition</span></a>(<span style="white-space:nowrap">?output:<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></span>):<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of complex polygon into simple components.
<br/><br/>
WARNING: This method is 'not' 100% robust. It may fail!
<br/><br/>
Produce a decomposition of a self intersecting, complex polygon into
a set of weakly-simple components.
<br/><br/>
This algorithm operates in O(n.log(n)) time and is based on the
Bentley-Ottmann algorithm.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>output</code> <p>If supplied, polygons will be appended to this list via 'add'
instead of a new list being constructed.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Nape list of GeomPoly's representing the decomposition.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is degenerate.</p></div><div class="indent inline-content"><code>#</code> <p>Any other error may be thrown if algorithm has failed, even
in release builds!</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="simplify"></a><h3><p><code><a href="#simplify"><span class="identifier">simplify</span></a>(<span style="white-space:nowrap">epsilon:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Simplify polygon.
<br/><br/>
Simplification is performed with an implementation of the Ramer-Douglas-Peucker
algorithm. The output polygon is formed via subset of the vertices in
the input polygon such that any discarded vertex is at most 'epsilon' pixels
away from the local output polygon.
<br/><br/>
This algorithm works on both simple and complex polygons, but please note
that this algorithm makes no guarantees on a simple polygon remaining simple
after simplification. This should not generally be a problem unless the epsilon
value is large with respect to the size of the features on the polygon.
<br/><br/>
Many of the geometric algorithms will mark vertices as important, such that
they will be guaranteed to exist after simplification (Such as preventing
gaps from opening up in marching squares when simplifying output polygons).
<br/><br/>
The average runtime of this algorithm is O(n.log(n)). This algorithm is
not stable in the sense that adding a new vertex to the polygon may drastically
change the result of simplifying the polygon.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>epsilon</code> <p>The distance from polygon at which vertices are ignored.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A new GeomPoly representing the result of the simplification.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If epsilon is &lt;= 0.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="size"></a><h3><p><code><a href="#size"><span class="identifier">size</span></a>():<a class="type" title="The standard Int type." href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>Determine number of vertices in polygon</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The number of vertices.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="skipBackwards"></a><h3><p><code><span class="label">inline</span> <a href="#skipBackwards"><span class="identifier">skipBackwards</span></a>(<span style="white-space:nowrap">times:<a class="type" title="The standard Int type." href="../../Int.html">Int</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Advance head of polygon backwards.
<br/><br/>
The current head of polygon will be moved backwards
the given number of times, with a negative value
being equivalent to performing a forwards advance.
<br/><br/>
<code>poly.skip_backwards(times)</code> is equivalent to
<code>poly.skip_forwards(-times)</code>
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.skipBackwards(2);</p>
<p>poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>                             (head)
</code></pre>
<p></pre></p>
<p>@params times The number of times to advance head backwards.</p>
<pre><code>          This value can be negative indicating a forwards
          advance.
</code></pre><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="skipForward"></a><h3><p><code><a href="#skipForward"><span class="identifier">skipForward</span></a>(<span style="white-space:nowrap">times:<a class="type" title="The standard Int type." href="../../Int.html">Int</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Advance head of polygon forward.
<br/><br/>
The current head of polygon will be moved forwards
the given number of times, with a negative value
being equivalent to performing a backwards advance.
<br/><br/>
<code>poly.skip_forwards(times)</code> is equivalent to
<code>poly.skip_backwards(-times)</code>
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.skipForwards(2);</p>
<p>poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>                       (head)
</code></pre>
<p></pre></p>
<p>@params times The number of times to advance head forward.</p>
<pre><code>          This value can be negative indicating a backwards
          advance.
</code></pre><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="toString"></a><h3><p><code><a href="#toString"><span class="identifier">toString</span></a>():<a class="type" title="The basic String class." href="../../String.html">String</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="field "><a name="top"></a><h3><p><code><a href="#top"><span class="identifier">top</span></a>():<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Find top most vertex of polygon.
<br/><br/>
If there is more than one such vertex then the result is indeterminate.
<br/><br/>
The Vec2 returned is intrinsically tied to the inner vertex like that
returned by current(). This method will not alter the current vertex.
This Vec2 is not able to be disposed of.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Vec2 representing the top most vertex.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is empty.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="transform"></a><h3><p><code><a href="#transform"><span class="identifier">transform</span></a>(<span style="white-space:nowrap">matrix:<a class="type" title="2D Matrix class representing affine transformations:  [ a  b  tx ] [ c  d  ty ] [ 0  0  1  ]  Note that in AS3, flash." href="../../nape/geom/Mat23.html">Mat23</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Transform polygon by given matrix.
<br/><br/>
Any transformation (not just equiorthogonal ones) are permitted, though
a transformation that causes polygon to be come degenerate is a bit
pointless.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>matrix</code> <p>The matrix to transform polygon by.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If matrix is null.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="triangularDecomposition"></a><h3><p><code><a href="#triangularDecomposition"><span class="identifier">triangularDecomposition</span></a>(<span style="white-space:nowrap">delaunay:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></span>):<a class="type" title="Nape list of GeomPoly type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/GeomPolyList.html">GeomPolyList</a></code></p></h3><div class="doc"><p>Produce a decomposition of weakly-simple polygon into triangles.
<br/><br/>
This algorithm 'should' be 100% robust and has been well test on for
example, the output of the Marching Squars utility which produces many
degenerate cases of weakly-simple polygons that have not yet broken this
algorithm!.
<br/><br/>
This algorithm operates in O(n.log(n)) time.
<br/><br/>
Vertices may be stripped from the polygon that are found to not be
necessary as part of making this algorithm robust.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>delaunay</code> <p>If true, then an O(n^2) pass will be made to mutate the original
triangulation to push it into a delanuay triangulation. (default false)</p></div><div class="indent inline-content"><code>output</code> <p>If supplied, polygons will be appended to this list via 'add'
instead of a new list being constructed.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A Nape list of GeomPoly's defining the decomposition.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If polygon is degenerate.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="unshift"></a><h3><p><code><a href="#unshift"><span class="identifier">unshift</span></a>(<span style="white-space:nowrap">vertex:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Unshift vertex to polygon.
<br/><br/>
A vertex will be allocated from a global object pool, and initialised
with the values of the given Vec2.
<br/><br/>
This vertex will be inserted before the current head, and the head
retreated to the newly inserted vertex, in this way successive unshifts
will insert elements in the expected reverse order.
<br/><br/>
Note that the Vec2 supplied as argument is only used to initialise the
inner Vertex.
<pre>
poly := -> A &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p>poly.unshift(X);</p>
<p>poly := -> A &lt;-> X &lt;-> B &lt;-> C &lt;-> D &lt;-> E &lt;-</p>
<pre><code>           (head)
</code></pre>
<p></pre></p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>vertex</code> <p>The Vec2 to be used in initialising the inner vertex.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to this polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If Vec2 is null, or has been disposed.</p></div><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div><div class="field "><a name="winding"></a><h3><p><code><a href="#winding"><span class="identifier">winding</span></a>():<a class="type" title="Enumeration represents the winding of a Polygon." href="../../nape/geom/Winding.html">Winding</a></code></p></h3><div class="doc"><p>Compute the winding order for this polygon.
<br/><br/>
The winding order can be conceptualised by thinking of an analog
clock face, if your polygon is the numbers on the clock then a
clockwise winding would have your polygon's vertices in numerical
order.
<br/><br/>
In the case of a non-simple polygon with self intersections then the
winding order is decided by how 'much' of the polygon is locally
clockwise wound, and how much is locally anti-clockwise wound.
<br/>
(Think of a figure 8 style polygon where one loop is larger than the
other. This larger loop will dictate the winding of the polygon.)
<br/><br/>
If no winding can be computed, then <code>Winding.UNDEFINED</code>
will be returned.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The winding of the polygon.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If this GeomPoly has been disposed.</p></div></div></div></div><h3 class="section">Static methods</h3><div class="fields"><div class="field "><a name="get"></a><h3><p><code><span class="label">static</span><a href="#get"><span class="identifier">get</span></a>(<span style="white-space:nowrap">?vertices:<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../Dynamic.html">Dynamic</a></span>):<a class="type" title="Polygon class with various geometric methods  This class represents a general Polygon, rather than the Polygon class which is physics shape." href="../../nape/geom/GeomPoly.html">GeomPoly</a></code></p></h3><div class="doc"><p>Allocate GeomPoly from object pool.
<br/><br/>
The vertices argument is typed Dynamic (* in AS3), and is permitted
to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
<br/><br/>
The input will be used to initialise the vertices of the polygon with
the head of the polygon pointing to the first vertex in input with vertices
inserted in forward order.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>vertices</code> <p>Vertex data to initialise polygon, or null for empty polygon.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>New GeomPoly representing input vertex data, allocated from object pool.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If input data is not of an expected Type.</p></div></div></div></div></div></div>        </div></div><footer><div class="footer-main"><div class=" container"><div class="footer-social"><iframe width="120px" scrolling="0" height="20px" frameborder="0" allowtransparency="true" src="http://ghbtns.com/github-btn.html?user=HaxeFlixel&amp;repo=flixel&amp;type=watch&amp;count=true&amp;size=small"></iframe><a href="https://twitter.com/haxeflixel" class="twitter-follow-button" data-show-count="true" data-lang="en" data-size="small">Follow @haxeflixel</a><script>!function (d, s, id){var js, fjs = d.getElementsByTagName (s)[0];if (!d.getElementById (id)){js = d.createElement (s);js.id = id;js.src = "//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore (js, fjs);}} (document, "script", "twitter-wjs");</script></div><div class="footer-powered-by"><p>HaxeFlixel is powered by</p><a href="http://haxe.org"><img src="http://www.haxeflixel.com/images/haxe.svg" alt="Haxe" title="Haxe"/></a>+<a href="http://openfl.org"><img class="openfl-footer-logo" src="http://www.haxeflixel.com//images/openfl.svg" alt="OpenFL" title="OpenFL"/></a>+<a href="http://flixel.org"><img class="flixel-footer-logo" src="http://www.haxeflixel.com//images/flixel.svg" alt="Flixel" title="Flixel"/></a></div></div></div></footer>    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script></body></html>