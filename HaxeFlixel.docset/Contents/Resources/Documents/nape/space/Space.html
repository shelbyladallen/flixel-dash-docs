<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../../jquery-1.9.1.min.js"></script><script src="../../bootstrap/js/bootstrap.min.js"></script><script src="../../bootstrap/js/bootstrap-select.min.js"></script><link href="../../styles.css" rel="stylesheet"/><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["types"]};</script><script type="text/javascript" src="../..//nav.js"></script><script type="text/javascript" src="../..//index.js"></script><link rel="icon" href="../..//favicon.ico" type="image/x-icon"></link><title>nape.space.Space - HaxeFlixel API</title></head><body><nav><div class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="http://www.haxeflixel.com/" class="navbar-brand"><img src="http://www.haxeflixel.com/images/haxeflixel-header.png" alt="HaxeFlixel"/></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="http://www.haxeflixel.com/demos">Demos</a></li><li><a href="http://www.haxeflixel.com/showcase">Showcase</a></li><li><a href="http://www.haxeflixel.com/blog">Blog</a></li><li><a href="http://www.haxeflixel.com/documentation">Docs</a></li><li class="active"><a href=".">API</a></li><li><a href="http://www.haxeflixel.com/forum">Forum</a></li></ul></div></div></div></nav><div class="container navbar-offset">        <div class="row-fluid container-main">            <div class="span3">              <div class="well sidebar-nav">                <form class="form-search" id="searchForm">                  <div class="input-prepend input-block-level">                    <span class="add-on"><i class="icon-search"></i></span>                    <input id="search" type="text" placeholder="Search" autocomplete="off"/>                  </div>                </form></div>              <div class="well sidebar-nav">                <div id="nav"></div>              </div>            </div>            <div class="span9"><div class="page-header"><span class="viewsource"><a href="https://github.com/deltaluca/nape/tree/master/cx-src/nape/space/Space.cx">View source</a></span><h4><small>package nape.space</small></h4><h1><small>class </small>Space</h1></div><div class="body"><div class="doc doc-main"><div class="indent"><p>The heart of all Nape simulations.</p></div></div><h3 class="section">Constructor</h3><div class="fields"><div class="field "><a name="new"></a><h3><p><code><a href="#new"><span class="identifier">new</span></a>(<span style="white-space:nowrap">?gravity:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>, <span style="white-space:nowrap">?broadphase:<a class="type" title="Enumeration of available broadphase collision types that Spaces may use." href="../../nape/space/Broadphase.html">Broadphase</a></span>)</code></p></h3><div class="doc"><p>Construct a new Space object.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>gravity</code> <p>The gravity of this space. (default &#40;0,0&#41;)</p></div><div class="indent inline-content"><code>broadphase</code> <p>The broadphase type to use. (default DYNAMIC_AABB_TREE)</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The constructed Space object.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If gravity is non-null, and has been disposed of.</p></div></div></div></div><h3 class="section">Variables</h3><div class="fields"><div class="field "><a name="arbiters"></a><h3><p><code><span class="label">read only</span><a href="#arbiters"><span class="identifier">arbiters</span></a>:<a class="type" title="Nape list of Arbiter type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/dynamics/ArbiterList.html">ArbiterList</a></code></p></h3><div class="doc"><p>List of all active arbiters in Space.
<br/><br/>
This list is immutable.</p></div></div><div class="field "><a name="bodies"></a><h3><p><code><span class="label">read only</span><a href="#bodies"><span class="identifier">bodies</span></a>:<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>List of all Bodys directly placed in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Body to this Space equivalent to: <code>body.space = space</code>
<br/><br/>
This list is only those bodies directly placed in the space, any
body that is a child of a Compound will not be in this list.</p></div></div><div class="field "><a name="broadphase"></a><h3><p><code><span class="label">read only</span><a href="#broadphase"><span class="identifier">broadphase</span></a>:<a class="type" title="Enumeration of available broadphase collision types that Spaces may use." href="../../nape/space/Broadphase.html">Broadphase</a></code></p></h3><div class="doc"><p>Broadphase type in use.</p></div></div><div class="field "><a name="compounds"></a><h3><p><code><span class="label">read only</span><a href="#compounds"><span class="identifier">compounds</span></a>:<a class="type" title="Nape list of Compound type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/CompoundList.html">CompoundList</a></code></p></h3><div class="doc"><p>List of all Compounds directly placed in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Compound to this Space equivalent to: <code>compound.space = space</code>
<br/><br/>
This list is only those compounds directly placed in the space, any
compound that is a child of another compound will not be in this list.</p></div></div><div class="field "><a name="constraints"></a><h3><p><code><span class="label">read only</span><a href="#constraints"><span class="identifier">constraints</span></a>:<a class="type" title="Nape list of Constraint type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/constraint/ConstraintList.html">ConstraintList</a></code></p></h3><div class="doc"><p>List of all Constraints directly placed in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Constraint to this Space equivalent to: <code>constraint.space = space</code>
<br/><br/>
This list is only those bodies directly placed in the space, any
constraint that is a child of a Compound will not be in this list.</p></div></div><div class="field "><a name="elapsedTime"></a><h3><p><code><span class="label">read only</span><a href="#elapsedTime"><span class="identifier">elapsedTime</span></a>:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>The elapsed simulation time.
<br/><br/>
This is the total amount of 'time' that has elapsed in the Space simulation.</p></div></div><div class="field "><a name="gravity"></a><h3><p><code><a href="#gravity"><span class="identifier">gravity</span></a>:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></p></h3><div class="doc"><p>Space gravity.
<br/><br/>
Units are of pixels/second/second</p></div></div><div class="field "><a name="listeners"></a><h3><p><code><span class="label">read only</span><a href="#listeners"><span class="identifier">listeners</span></a>:<a class="type" title="Nape list of Listener type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/ListenerList.html">ListenerList</a></code></p></h3><div class="doc"><p>List of all Listeners in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Listener to this Space equivalent to: <code>listener.space = space</code></p></div></div><div class="field "><a name="liveBodies"></a><h3><p><code><span class="label">read only</span><a href="#liveBodies"><span class="identifier">liveBodies</span></a>:<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>List of all active dynamic Bodies in space.
<br/><br/>
This list contains all dynamic bodies that are awake regardless of their containment in a Compound.
<br/><br/>
This list is immutable.</p></div></div><div class="field "><a name="liveConstraints"></a><h3><p><code><span class="label">read only</span><a href="#liveConstraints"><span class="identifier">liveConstraints</span></a>:<a class="type" title="Nape list of Constraint type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/constraint/ConstraintList.html">ConstraintList</a></code></p></h3><div class="doc"><p>List of all active Constraints in space.
<br/><br/>
This list contains all constraints regardless of their containment in a Compound.
<br/><br/>
This list is immutable.</p></div></div><div class="field "><a name="sortContacts"></a><h3><p><code><a href="#sortContacts"><span class="identifier">sortContacts</span></a>:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Flag controlling sorting of contact points.
<br/><br/>
If true, then collisions will be resolved in an order defined by their
penetration depths. This can be shown to improve stability of the physics
as well as making simulations more consistent regardless of which broadphase
is used.
<br/><br/>
Having sorting enabled obviously incurs a cost, and you may consider
disabling it if you are having issues with performance (Though things
such as number of physics iterations will have much greater bearing on
performance than this, especcialy since enabling this may permit you
to use less iterations).</p></div></div><div class="field "><a name="timeStamp"></a><h3><p><code><span class="label">read only</span><a href="#timeStamp"><span class="identifier">timeStamp</span></a>:<a class="type" title="The standard Int type." href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>The time stamp of this Space object.
<br/><br/>
This is equal to the number of times that space.step(..) has been invoked.</p></div></div><div class="field "><a name="userData"></a><h3><p><code><span class="label">read only</span><a href="#userData"><span class="identifier">userData</span></a>:<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../Dynamic.html">Dynamic</a>&lt;<a class="type" title="Dynamic is a special type which is compatible with all other types." href="../../Dynamic.html">Dynamic</a>&gt;</code></p></h3><div class="doc"><p>Dynamic object for user to store additional data.
<br/><br/>
This object cannot be set, only its dynamically created
properties may be set. In AS3 the type of this property is &amp;#42
<br/><br/>
This object will be lazily constructed so that until accessed
for the first time, will be null internally.</p></div></div><div class="field "><a name="world"></a><h3><p><code><span class="label">read only</span><a href="#world"><span class="identifier">world</span></a>:<a class="type" title="Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a></code></p></h3><div class="doc"><p>Static, immutable Body for constraint purposes.
<br/><br/>
This is a completely static, uncollidable, uninteractable Body
with no Shapes, that cannot be modified in any way.
<br/><br/>
Its purpose is to provide a means for attaching Constraints
from one Body to the Space itself, for instance pinning a body
against a static point in space.</p></div></div><div class="field "><a name="worldAngularDrag"></a><h3><p><code><a href="#worldAngularDrag"><span class="identifier">worldAngularDrag</span></a>:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Angular drag applied to all bodies in Space.
<br/><br/>
This represents the fraction of a body's angular velocity which will be
removed per second. This value has no unit attached.</p></div></div><div class="field "><a name="worldLinearDrag"></a><h3><p><code><a href="#worldLinearDrag"><span class="identifier">worldLinearDrag</span></a>:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></p></h3><div class="doc"><p>Linear drag applied to all bodies in Space.
<br/><br/>
This represents the fraction of a body's linear velocity which will be
removed per second. This value has no unit attached.</p></div></div><div class="field "><a name="zpp_inner"></a><h3><p><code><a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<span class="type">ZPP_Space</span><span> = null</span></code></p></h3><div class="doc"><p>@private</p></div></div></div><h3 class="section">Methods</h3><div class="fields"><div class="field "><a name="bodiesInAABB"></a><h3><p><code><a href="#bodiesInAABB"><span class="identifier">bodiesInAABB</span></a>(<span style="white-space:nowrap">aabb:<a class="type" title="Axis Aligned Bounding Box (AABB)  Note that in many cases of an AABB object being returned by a Nape function the AABB object will be marked internally as an 'immutable' AABB." href="../../nape/geom/AABB.html">AABB</a></span>, <span style="white-space:nowrap">containment:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">strict:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = true</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given an AABB.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the AABB, whose filter agrees to collide
will be considered.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>aabb</code> <p>The bounding box to query bodies by,</p></div><div class="indent inline-content"><code>containment</code> <p>If true, then only Bodies entirely contained (Rather
than simply intersecting) will be considered.
(default false)</p></div><div class="indent inline-content"><code>strict</code> <p>If false, then the body's shape's bounding box will be used to
classify the shapes of the body, instead of the Shape itself.
(default true)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given AABB.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If AABB is null, or is degenerate.</p></div></div></div><div class="field "><a name="bodiesInBody"></a><h3><p><code><a href="#bodiesInBody"><span class="identifier">bodiesInBody</span></a>(<span style="white-space:nowrap">body:<a class="type" title="Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a></span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given a Body.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the input body, whose filter agrees to collide
will be considered. The input body is considered a purely geometric</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>body</code> <p>The body to use in classifying other bodies.</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the bodies for given body.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If body is null.</p></div><div class="indent inline-content"><code>#</code> <p>If body has a shape that is a polygon, and that polygon is not 'valid'</p></div></div></div><div class="field "><a name="bodiesInCircle"></a><h3><p><code><a href="#bodiesInCircle"><span class="identifier">bodiesInCircle</span></a>(<span style="white-space:nowrap">position:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>, <span style="white-space:nowrap">radius:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></span>, <span style="white-space:nowrap">containment:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given a circle.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the circle, whose filter agrees to collide
will be considered.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>position</code> <p>The position of the centre of the circle.</p></div><div class="indent inline-content"><code>radius</code> <p>The radius of the circle.</p></div><div class="indent inline-content"><code>containment</code> <p>If true, then only Bodies entirely contained (Rather
than simply intersecting) will be considered. If a
filter is supplied, only shapes that agree to collide
will be used in this containment check.
(default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given circle.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If positions is null or disposed of.</p></div><div class="indent inline-content"><code>#</code> <p>If radius is not strictly positive.</p></div></div></div><div class="field "><a name="bodiesInShape"></a><h3><p><code><a href="#bodiesInShape"><span class="identifier">bodiesInShape</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="" href="../../nape/shape/Shape.html">Shape</a></span>, <span style="white-space:nowrap">containment:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies given a shape.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the input shape, whose filter agrees to collide
will be considered. The input shape is considered a purely geometric
<br/><br/>
The input shape must be part of a Body so as to be well defined.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>shape</code> <p>The shape to use in classifying other shapes.</p></div><div class="indent inline-content"><code>containment</code> <p>If true, then only Bodies entirely contained (Rather
than simply intersecting) will be considered.
(default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the bodies for given shape.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If shape is null or not part of a body.</p></div><div class="indent inline-content"><code>#</code> <p>If shape is a polygon, and that polygon is not 'valid'</p></div></div></div><div class="field "><a name="bodiesUnderPoint"></a><h3><p><code><a href="#bodiesUnderPoint"><span class="identifier">bodiesUnderPoint</span></a>(<span style="white-space:nowrap">point:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></p></h3><div class="doc"><p>Evaluate all Bodies under a given Point.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape containing
the given point whose filter agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>point</code> <p>The point to evaluate bodies.</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the Bodies containing the given point.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If point is null or disposed of.</p></div></div></div><div class="field "><a name="clear"></a><h3><p><code><a href="#clear"><span class="identifier">clear</span></a>():<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Clear the Space of all objects.
<br/><br/>
Things such as the elapsed simulation time, and time step will too be
reset to 0.
<br/><br/>
Parameters such as gravity, and worldLinearDrag will be untouched by
this operation.</p></div></div><div class="field "><a name="convexCast"></a><h3><p><code><a href="#convexCast"><span class="identifier">convexCast</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="" href="../../nape/shape/Shape.html">Shape</a></span>, <span style="white-space:nowrap">deltaTime:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></span>, <span style="white-space:nowrap">liveSweep:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>):<a class="type" title="Null can be useful in two cases." href="../../Null.html">Null</a>&lt;<a class="type" title="Class representing the results of a convex cast operation." href="../../nape/geom/ConvexResult.html">ConvexResult</a>&gt;</code></p></h3><div class="doc"><p>Perform a convex cast for soonest collision.
<br/><br/>
This method will return only the soonest collision result (if any), to find
more than this, use the convexMultiCast method. The shape will not be
swept further than the time delta provided.
Shapes already intersecting
the sweep shape at t = 0 are ignored.
<br/><br/>
If the filter argument is null, then all shapes will be collidable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>shape</code> <p>The Shape to be cast through space. This shape must belong
to a body whose velocity is used to define the sweep.</p></div><div class="indent inline-content"><code>deltaTime</code> <p>The amount of time to sweep the shape forward.</p></div><div class="indent inline-content"><code>liveSweep</code> <p>If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The soonest result (if any) of convex intersection.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If shape is null, or not part of a body.</p></div><div class="indent inline-content"><code>#</code> <p>If deltaTime is negative.</p></div></div></div><div class="field "><a name="convexMultiCast"></a><h3><p><code><a href="#convexMultiCast"><span class="identifier">convexMultiCast</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="" href="../../nape/shape/Shape.html">Shape</a></span>, <span style="white-space:nowrap">deltaTime:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></span>, <span style="white-space:nowrap">liveSweep:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">output:<a class="type" title="Nape list of ConvexResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/ConvexResultList.html">ConvexResultList</a></span>):<a class="type" title="Nape list of ConvexResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/ConvexResultList.html">ConvexResultList</a></code></p></h3><div class="doc"><p>Perform a convex cast for all collisions in time order.
<br/><br/>
This method will return all collisions, or an empty list if there are none.
The shape will not be
swept further than the time delta provided. Shapes already intersecting
the sweep shape at t = 0 are ignored.
<br/><br/>
If the filter argument is null, then all shapes will be collidable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>shape</code> <p>The Shape to be cast through space. This shape must belong
to a body whose velocity is used to define the sweep.</p></div><div class="indent inline-content"><code>deltaTime</code> <p>The amount of time to sweep the shape forward.</p></div><div class="indent inline-content"><code>liveSweep</code> <p>If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>A list to append results to instead of allocating a new one (default null)</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The collision results in time order.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If shape is null, or not part of a body.</p></div><div class="indent inline-content"><code>#</code> <p>If deltaTime is negative.</p></div></div></div><div class="field "><a name="interactionType"></a><h3><p><code><a href="#interactionType"><span class="identifier">interactionType</span></a>(<span style="white-space:nowrap">shape1:<a class="type" title="" href="../../nape/shape/Shape.html">Shape</a></span>, <span style="white-space:nowrap">shape2:<a class="type" title="" href="../../nape/shape/Shape.html">Shape</a></span>):<a class="type" title="Null can be useful in two cases." href="../../Null.html">Null</a>&lt;<a class="type" title="Enumeration of Interaction types." href="../../nape/callbacks/InteractionType.html">InteractionType</a>&gt;</code></p></h3><div class="doc"><p>Determine the interaction type that would occur between a pair of Shapes.
<br/><br/>
This function takes into account everything possible, and ignoring the
callback system will tell you precisely the type of interaction (if any
at all) which will occur between these Shapes.
<br/><br/>
This function can only work if the Shapes belong to a Body.
<br/><br/>
This function can only make use of any constraints 'ignore' property
to determine if 'null' should be returned if the constraints being used
are inside of a Space.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>shape1</code> <p>The first Shape to test.</p></div><div class="indent inline-content"><code>shape2</code> <p>The second Shape to test.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The interaction type that will occur between these shapes, or null
if no interaction will occur.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If either shape is null, or is not contained within a body.</p></div></div></div><div class="field "><a name="rayCast"></a><h3><p><code><a href="#rayCast"><span class="identifier">rayCast</span></a>(<span style="white-space:nowrap">ray:<a class="type" title="Parametrically defined ray used in ray casting functions." href="../../nape/geom/Ray.html">Ray</a></span>, <span style="white-space:nowrap">inner:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>):<a class="type" title="Null can be useful in two cases." href="../../Null.html">Null</a>&lt;<a class="type" title="Class representing the results of a ray cast operation." href="../../nape/geom/RayResult.html">RayResult</a>&gt;</code></p></h3><div class="doc"><p>Perform a ray cast for closest result.
<br/><br/>
This method will return only the closest result (if any), to find more
the first result, use the rayMultiCast method. The ray will not be
cast beyond its maxDistance.
<br/><br/>
If the filter argument is null, then all shapes will be intersectable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>ray</code> <p>The ray to cast through space.</p></div><div class="indent inline-content"><code>inner</code> <p>If true then inner surfaces of shapes will also be intersected.
otherwise only the outer surfaces. (default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The closest result (if any) of ray intersection.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If ray is null.</p></div></div></div><div class="field "><a name="rayMultiCast"></a><h3><p><code><a href="#rayMultiCast"><span class="identifier">rayMultiCast</span></a>(<span style="white-space:nowrap">ray:<a class="type" title="Parametrically defined ray used in ray casting functions." href="../../nape/geom/Ray.html">Ray</a></span>, <span style="white-space:nowrap">inner:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of RayResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/RayResultList.html">RayResultList</a></span>):<a class="type" title="Nape list of RayResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/RayResultList.html">RayResultList</a></code></p></h3><div class="doc"><p>Perform a ray cast for all valid results.
<br/><br/>
This method will return all intersections (in distance order) of ray
with shapes in the space up to the ray's maxDistance.
<br/><br/>
If the filter argument is null, then all shapes will be intersectable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>ray</code> <p>The ray to cast through space.</p></div><div class="indent inline-content"><code>inner</code> <p>If true then inner surfaces of shapes will also be intersected.
otherwise only the outer surfaces. (default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>A list to append results to instead of allocating a new one (default null)</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>All valid results of ray cast in distance order from closest to furthest.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If ray is null.</p></div></div></div><div class="field "><a name="shapesInAABB"></a><h3><p><code><a href="#shapesInAABB"><span class="identifier">shapesInAABB</span></a>(<span style="white-space:nowrap">aabb:<a class="type" title="Axis Aligned Bounding Box (AABB)  Note that in many cases of an AABB object being returned by a Nape function the AABB object will be marked internally as an 'immutable' AABB." href="../../nape/geom/AABB.html">AABB</a></span>, <span style="white-space:nowrap">containment:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">strict:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = true</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given an AABB.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>aabb</code> <p>The bounding box to query shapes by,</p></div><div class="indent inline-content"><code>containment</code> <p>If true, then only Shapes entirely contained (Rather
than simply intersected) will be considered.
(default false)</p></div><div class="indent inline-content"><code>strict</code> <p>If false, then the Shape's bounding box will be used to
classify the Shape, instead of the Shape itself.
(default true)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given AABB.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If AABB is null, or is degenerate.</p></div></div></div><div class="field "><a name="shapesInBody"></a><h3><p><code><a href="#shapesInBody"><span class="identifier">shapesInBody</span></a>(<span style="white-space:nowrap">body:<a class="type" title="Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a></span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given a Body.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered. The input body's shape's own filters
are never used in this method. The input body is considered a purely
geometric object.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>body</code> <p>The body to use in classifying other shapes.</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given body.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If body is null.</p></div><div class="indent inline-content"><code>#</code> <p>If body has a shape that is a polygon, and that polygon is not 'valid'</p></div></div></div><div class="field "><a name="shapesInCircle"></a><h3><p><code><a href="#shapesInCircle"><span class="identifier">shapesInCircle</span></a>(<span style="white-space:nowrap">position:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>, <span style="white-space:nowrap">radius:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></span>, <span style="white-space:nowrap">containment:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given a circle.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>position</code> <p>The position of the centre of the circle.</p></div><div class="indent inline-content"><code>radius</code> <p>The radius of the circle.</p></div><div class="indent inline-content"><code>containment</code> <p>If true, then only Shapes entirely contained (Rather
than simply intersected) will be considered.
(default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given circle.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If positions is null or disposed of.</p></div><div class="indent inline-content"><code>#</code> <p>If radius is not strictly positive.</p></div></div></div><div class="field "><a name="shapesInShape"></a><h3><p><code><a href="#shapesInShape"><span class="identifier">shapesInShape</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="" href="../../nape/shape/Shape.html">Shape</a></span>, <span style="white-space:nowrap">containment:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes given another shape.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered. The input shape's own filter
is never used in this method. The input shape is considered a purely
geometric object.
<br/><br/>
The input shape must be part of a Body so as to be well defined.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>shape</code> <p>The shape to use in classifying other shapes.</p></div><div class="indent inline-content"><code>containment</code> <p>If true, then only Shapes entirely contained (Rather
than simply intersected) will be considered.
(default false)</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given shape.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If shape is null or not part of a body.</p></div><div class="indent inline-content"><code>#</code> <p>If shape is a polygon, and that polygon is not 'valid'</p></div></div></div><div class="field "><a name="shapesUnderPoint"></a><h3><p><code><a href="#shapesUnderPoint"><span class="identifier">shapesUnderPoint</span></a>(<span style="white-space:nowrap">point:<a class="type" title="2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></span>, <span style="white-space:nowrap">?filter:<a class="type" title="InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>, <span style="white-space:nowrap">?output:<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></p></h3><div class="doc"><p>Evaluate all Shapes under a given Point.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>point</code> <p>The point to evaluate shapes.</p></div><div class="indent inline-content"><code>filter</code> <p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></div><div class="indent inline-content"><code>output</code> <p>Optional list to append results to instead of creating a new list (default null).</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the Shapes containing the given point.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If point is null or disposed of.</p></div></div></div><div class="field "><a name="step"></a><h3><p><code><a href="#step"><span class="identifier">step</span></a>(<span style="white-space:nowrap">deltaTime:<a class="type" title="The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></span>, <span style="white-space:nowrap">velocityIterations:<a class="type" title="The standard Int type." href="../../Int.html">Int</a> = 10</span>, <span style="white-space:nowrap">positionIterations:<a class="type" title="The standard Int type." href="../../Int.html">Int</a> = 10</span>):<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Step simulation forward in time.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>deltaTime</code> <p>The number of seconds to simulate. For 60fps physics
you would use a value of 1/60.</p></div><div class="indent inline-content"><code>velocityIterations</code> <p>The number of iterations to use in resolving
errors in the velocities of objects. This is
together with collision detection the most
expensive phase of a simulation update, as well
as the most important for stable results.
(default 10)</p></div><div class="indent inline-content"><code>positionIterations</code> <p>The number of iterations to use in resolving
errors in the positions of objects. This is
far more lightweight than velocity iterations,
as well as being less important for the
stability of results. (default 10)</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If deltaTime is not strictly positive.</p></div><div class="indent inline-content"><code>#</code> <p>If either of the number of iterations is not strictly positive.</p></div></div></div><div class="field "><a name="visitBodies"></a><h3><p><code><a href="#visitBodies"><span class="identifier">visitBodies</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>&#8209;&gt<a class="type" title="The standard Void type." href="../../Void.html">Void</a></span>):<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Apply given function to all bodies in space.
<br/><br/>
This method is a way to iterate over 'every' Body in the Space
regardless of containment in a Compound.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>lambda</code> <p>The function to apply to each Body.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If lambda is null.</p></div></div></div><div class="field "><a name="visitCompounds"></a><h3><p><code><a href="#visitCompounds"><span class="identifier">visitCompounds</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="Compound represents a grouping of physics objects into a single object." href="../../nape/phys/Compound.html">Compound</a>&#8209;&gt<a class="type" title="The standard Void type." href="../../Void.html">Void</a></span>):<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Apply given function to all compounds in space.
<br/><br/>
This method is a way to iterate over 'every' Compound in the Space
regardless of containment in another Compound.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>lambda</code> <p>The function to apply to each Compound.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If lambda is null.</p></div></div></div><div class="field "><a name="visitConstraints"></a><h3><p><code><a href="#visitConstraints"><span class="identifier">visitConstraints</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="" href="../../nape/constraint/Constraint.html">Constraint</a>&#8209;&gt<a class="type" title="The standard Void type." href="../../Void.html">Void</a></span>):<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Apply given function to all constraints in space.
<br/><br/>
This method is a way to iterate over 'every' Constraint in the Space
regardless of containment in a Compound.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>lambda</code> <p>The function to apply to each Constraint.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If lambda is null.</p></div></div></div></div></div></div>        </div></div><footer><div class="footer-main"><div class=" container"><div class="footer-social"><iframe width="120px" scrolling="0" height="20px" frameborder="0" allowtransparency="true" src="http://ghbtns.com/github-btn.html?user=HaxeFlixel&amp;repo=flixel&amp;type=watch&amp;count=true&amp;size=small"></iframe><a href="https://twitter.com/haxeflixel" class="twitter-follow-button" data-show-count="true" data-lang="en" data-size="small">Follow @haxeflixel</a><script>!function (d, s, id){var js, fjs = d.getElementsByTagName (s)[0];if (!d.getElementById (id)){js = d.createElement (s);js.id = id;js.src = "//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore (js, fjs);}} (document, "script", "twitter-wjs");</script></div><div class="footer-powered-by"><p>HaxeFlixel is powered by</p><a href="http://haxe.org"><img src="http://www.haxeflixel.com/images/haxe.svg" alt="Haxe" title="Haxe"/></a>+<a href="http://openfl.org"><img class="openfl-footer-logo" src="http://www.haxeflixel.com//images/openfl.svg" alt="OpenFL" title="OpenFL"/></a>+<a href="http://flixel.org"><img class="flixel-footer-logo" src="http://www.haxeflixel.com//images/flixel.svg" alt="Flixel" title="Flixel"/></a></div></div></div></footer>    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script></body></html>