<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><link href="../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../../jquery-1.9.1.min.js"></script><script src="../../bootstrap/js/bootstrap.min.js"></script><script src="../../bootstrap/js/bootstrap-select.min.js"></script><link href="../../styles.css" rel="stylesheet"/><script type="text/javascript">var dox = {rootPath: "../../",platforms: ["types"]};</script><script type="text/javascript" src="../..//nav.js"></script><script type="text/javascript" src="../..//index.js"></script><link rel="icon" href="../..//favicon.ico" type="image/x-icon"></link><title>nape.callbacks.CbTypeList - HaxeFlixel API</title></head><body><nav><div class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="http://www.haxeflixel.com/" class="navbar-brand"><img src="http://www.haxeflixel.com/images/haxeflixel-header.png" alt="HaxeFlixel"/></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="http://www.haxeflixel.com/demos">Demos</a></li><li><a href="http://www.haxeflixel.com/showcase">Showcase</a></li><li><a href="http://www.haxeflixel.com/blog">Blog</a></li><li><a href="http://www.haxeflixel.com/documentation">Docs</a></li><li class="active"><a href=".">API</a></li><li><a href="http://www.haxeflixel.com/forum">Forum</a></li></ul></div></div></div></nav><div class="container navbar-offset">        <div class="row-fluid container-main">            <div class="span3">              <div class="well sidebar-nav">                <form class="form-search" id="searchForm">                  <div class="input-prepend input-block-level">                    <span class="add-on"><i class="icon-search"></i></span>                    <input id="search" type="text" placeholder="Search" autocomplete="off"/>                  </div>                </form></div>              <div class="well sidebar-nav">                <div id="nav"></div>              </div>            </div>            <div class="span9"><div class="page-header"><span class="viewsource"><a href="https://github.com/deltaluca/nape/tree/master/cx-src/nape/callbacks/CbTypeList.cx">View source</a></span><h4><small>package nape.callbacks</small></h4><h1><small>class </small>CbTypeList</h1></div><div class="body"><div class="doc doc-main"><div class="indent"><p>Nape list of CbType type objects
<br/><br/>
Internally this list is at present implemented as a linked list with
object pooled nodes and iterators with various fast paths made for
standard access patterns (For instance accessing successive elements
runs in constant time when using random access functions)
<br/><br/>
Iteration of this list can be done in various ways, but the preferred
way on all targets, is through use of the foreach function:
<pre>
list.foreach(function (obj) {
});
</pre>
This method is inlined so that in haxe no closure will need to be created.
<br/><br/>
In AS3, a closure would need to be created in general, so for performance
reasons you 'may' choose to use iteration as follows:
<pre>
for (var i:int = 0; i &lt; list.length; i++) {</p>
<pre><code>var obj:CbType = list.at(i);
</code></pre>
<p>}
</pre>
<br/>
NOTE: It is 'not' safe to modify a list whilst iterating over it.
If you wish to remove elements during an iteration you should use the
filter method, for example:
<pre>
list.filter(function (obj) {</p>
<pre><code>// operate on object.
// ...
return (false if you want object to be removed);
</code></pre>
<p>});
</pre>
<br/><br/>
In AS3, if you wish to avoid a closure generation, you can perform such
an iteration in a safe manner as follows:
<pre>
var i:int = 0;
while (i &lt; list.length) {</p>
<pre><code>var obj:CbType = list.at(i);
// operate on object.
// ...
if (should remove obj) {
    list.remove(obj);
    continue;
}
else i++;
</code></pre>
<p>}
</pre>
Or if you are always clearing the list entirely you could write:
<pre>
while (!list.empty()) {</p>
<pre><code>var obj:CbType = list.pop();
// operate on object.
// ...
</code></pre>
<p>}
</pre></p></div></div><h3 class="section">Constructor</h3><div class="fields"><div class="field "><a name="new"></a><h3><p><code><a href="#new"><span class="identifier">new</span></a>()</code></p></h3><div class="doc"><p>Construct a new list.</p></div></div></div><h3 class="section">Variables</h3><div class="fields"><div class="field "><a name="length"></a><h3><p><code><span class="label">read only</span><a href="#length"><span class="identifier">length</span></a>:<a class="type" title="The standard Int type." href="../../Int.html">Int</a></code></p></h3><div class="doc"><p>Length of list.</p></div></div><div class="field "><a name="zpp_inner"></a><h3><p><code><a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<span class="type">ZPP_CbTypeList</span><span> = null</span></code></p></h3><div class="doc"><p>@private</p></div></div></div><h3 class="section">Methods</h3><div class="fields"><div class="field "><a name="add"></a><h3><p><code><span class="label">inline</span> <a href="#add"><span class="identifier">add</span></a>(<span style="white-space:nowrap">obj:<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Insert element into list in most effecient way.
<br/><br/>
This method will defer to either the push or unshift function
depending on which is most effecient in the context.
<br/><br/>
If order of elements is not important then you should always use
this function to insert elements.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>obj</code> <p>The object to insert.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if object was successfuly inserted.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If list is immutable</p></div></div></div><div class="field "><a name="at"></a><h3><p><code><a href="#at"><span class="identifier">at</span></a>(<span style="white-space:nowrap">index:<a class="type" title="The standard Int type." href="../../Int.html">Int</a></span>):<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></code></p></h3><div class="doc"><p>Random access to elements of list by index.
<br/><br/>
Under normal circumstances, accessing succesive elements via this
method will occur in constant time.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>index</code> <p>The index of the element in list to access.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The element at the given index.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If index is out of bounds.</p></div></div></div><div class="field "><a name="clear"></a><h3><p><code><a href="#clear"><span class="identifier">clear</span></a>():<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Clear the list, removing all elements.</p><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If list is iummutable</p></div></div></div><div class="field "><a name="copy"></a><h3><p><code><a href="#copy"><span class="identifier">copy</span></a>(<span style="white-space:nowrap">deep:<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>):<a class="type" title="Nape list of CbType type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/CbTypeList.html">CbTypeList</a></code></p></h3><div class="doc"><p>Produce a possibly deep copy of list.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>deep</code> <p>If true, then each element will have its own copy
function called instead of simply having its
reference copied over.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The copied list.</p></div></div></div><div class="field "><a name="empty"></a><h3><p><code><span class="label">inline</span> <a href="#empty"><span class="identifier">empty</span></a>():<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Test if list is empty or not.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if list is empty.</p></div></div></div><div class="field "><a name="filter"></a><h3><p><code><a href="#filter"><span class="identifier">filter</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a>&#8209;&gt<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></span>):<a class="type" title="Nape list of CbType type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/CbTypeList.html">CbTypeList</a></code></p></h3><div class="doc"><p>Iterate over list filtering elements.
<br/><br/>
The given function will be applied to each element, whenever the
function returns false, the element will be removed from the list.
<br/><br/>
Any exception thrown by the supplied function will be treat as a
signal to halt iteration acting as a 'break' statement.
<br/><br/>
This method is to be greatly preferred for filtering logic as
it is otherwise unsafe to modify the list during an iteration.
<br/><br/>
An example of using this method to clean up a list whilst performing
actions on the elements.
<pre>
list.filter(function (obj) {
// perform clean up with obj
return false; // remove from list.
});
</pre></p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>lambda</code> <p>The function to apply to each argument, deciding if
element should be removed.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to 'this' list.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If lambda argument is null.</p></div></div></div><div class="field "><a name="foreach"></a><h3><p><code><span class="label">inline</span> <a href="#foreach"><span class="identifier">foreach</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a>&#8209;&gt<a class="type" title="The standard Void type." href="../../Void.html">Void</a></span>):<a class="type" title="Nape list of CbType type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/CbTypeList.html">CbTypeList</a></code></p></h3><div class="doc"><p>Iterate over list applying function.
<br/><br/>
Any exception thrown by the supplied function will be treat as a
signal to halt iteration acting as a 'break' statement.
<br/><br/>
This method should be preferred to using standard haxe iteration
as there will be no allocation of an iterator object.
<pre>
list.foreach(function (obj) {</p>
<pre><code>if (ignore_object(obj)) return; //acts as a 'continue' statement
if (halt_iteration(obj)) throw "": //acts as a 'break' statement
</code></pre>
<p>});
</pre></p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>lambda</code> <p>The function to apply to each argument.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A reference to 'this' list.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If lambda argument is null.</p></div></div></div><div class="field "><a name="has"></a><h3><p><code><a href="#has"><span class="identifier">has</span></a>(<span style="white-space:nowrap">obj:<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Check if element is already in the list</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>obj</code> <p>The object to test.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if object is in the list.</p></div></div></div><div class="field "><a name="iterator"></a><h3><p><code><span class="label">inline</span> <a href="#iterator"><span class="identifier">iterator</span></a>():<a class="type" title="Haxe Iterator compatible iterator over Nape list." href="../../nape/callbacks/CbTypeIterator.html">CbTypeIterator</a></code></p></h3><div class="doc"><p>Return Haxe iterator for list.
<br/><br/>
Use of this iterator, whilst stylistically better in Haxe should not
be used, in preference for use of the foreach function which will
not require allocation of an iterator object.
<br/><br/>
Equally in AS3, the foreach method should be the preferred way to iterate.</p></div></div><div class="field "><a name="merge"></a><h3><p><code><a href="#merge"><span class="identifier">merge</span></a>(<span style="white-space:nowrap">xs:<a class="type" title="Nape list of CbType type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/CbTypeList.html">CbTypeList</a></span>):<a class="type" title="The standard Void type." href="../../Void.html">Void</a></code></p></h3><div class="doc"><p>Merge given list into this one.
<br/><br/>
The result is that this list will have all objects from the argument
that were not already in the list inserted. You should make no
assumption about the order of these insertions.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>xs</code> <p>The list to merge.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If xs argument is null.</p></div></div></div><div class="field "><a name="pop"></a><h3><p><code><a href="#pop"><span class="identifier">pop</span></a>():<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></code></p></h3><div class="doc"><p>Pop element from back of list.
<br/><br/>
If you are wanting to clear a list, whilst operating on its elements,
consider use of the filter method instead.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The element removed from list.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If list is immutable.</p></div><div class="indent inline-content"><code>#</code> <p>If the list is empty.</p></div></div></div><div class="field "><a name="push"></a><h3><p><code><a href="#push"><span class="identifier">push</span></a>(<span style="white-space:nowrap">obj:<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Push element to back of list.
<br/><br/>
When the order of objects is not important, it is best to use the
add() method instead.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>obj</code> <p>The object to insert.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if object was successively inserted.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If list is immutable.</p></div></div></div><div class="field "><a name="remove"></a><h3><p><code><a href="#remove"><span class="identifier">remove</span></a>(<span style="white-space:nowrap">obj:<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Remove element from list.
<br/><br/>
This is a linear time operation.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>obj</code> <p>The object to remove</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if object was removed from list.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If list is immutable</p></div></div></div><div class="field "><a name="shift"></a><h3><p><code><a href="#shift"><span class="identifier">shift</span></a>():<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></code></p></h3><div class="doc"><p>Pop element from front of list.
<br/><br/>
If you are wanting to clear a list, whilst operating on its elements,
consider use of the filter method instead.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The element removed from list.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If list is immutable.</p></div><div class="indent inline-content"><code>#</code> <p>If the list is empty.</p></div></div></div><div class="field "><a name="toString"></a><h3><p><code><a href="#toString"><span class="identifier">toString</span></a>():<a class="type" title="The basic String class." href="../../String.html">String</a></code></p></h3><div class="doc"><p>@private</p></div></div><div class="field "><a name="unshift"></a><h3><p><code><a href="#unshift"><span class="identifier">unshift</span></a>(<span style="white-space:nowrap">obj:<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a></span>):<a class="type" title="The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></p></h3><div class="doc"><p>Push element to front of list.
<br/><br/>
When the order of objects is not important, it is best to use the
add() method instead.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>obj</code> <p>The object to insert.</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if object was successively inserted.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If list is immutable.</p></div></div></div></div><h3 class="section">Static methods</h3><div class="fields"><div class="field "><a name="fromArray"></a><h3><p><code><span class="label">static</span><a href="#fromArray"><span class="identifier">fromArray</span></a>(<span style="white-space:nowrap">array:<a class="type" title="An Array is a storage for values." href="../../Array.html">Array</a>&lt;<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a>&gt;</span>):<a class="type" title="Nape list of CbType type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/CbTypeList.html">CbTypeList</a></code></p></h3><div class="doc"><p>Convert standard Array to Nape list.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>array</code> <p>The array to be converted</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>An equivalent Nape list.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>If</code> <p>array argument is null.</p></div><div class="indent inline-content"><code>If</code> <p>array contains elements of type other than CbType</p></div></div></div><div class="field "><a name="fromVector"></a><h3><p><code><span class="label">static</span><a href="#fromVector"><span class="identifier">fromVector</span></a>(<span style="white-space:nowrap">vector:<a class="type" title="" href="../../flash/Vector.html">Vector</a>&lt;<a class="type" title="Callback Type applied to Interactors and Constraints." href="../../nape/callbacks/CbType.html">CbType</a>&gt;</span>):<a class="type" title="Nape list of CbType type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/CbTypeList.html">CbTypeList</a></code></p></h3><div class="doc"><p>Convert flash.Vector to Nape list.</p><p class="javadoc">Parameters:</p><div class="indent inline-content"><code>vector</code> <p>The vector to be converted</p></div><p class="javadoc">Returns:</p><div class="indent inline-content"><p>An equivalent Nape list.</p></div><p class="javadoc">Throws:</p><div class="indent inline-content"><code>#</code> <p>If vector argument is null.</p></div></div></div></div></div></div>        </div></div><footer><div class="footer-main"><div class=" container"><div class="footer-social"><iframe width="120px" scrolling="0" height="20px" frameborder="0" allowtransparency="true" src="http://ghbtns.com/github-btn.html?user=HaxeFlixel&amp;repo=flixel&amp;type=watch&amp;count=true&amp;size=small"></iframe><a href="https://twitter.com/haxeflixel" class="twitter-follow-button" data-show-count="true" data-lang="en" data-size="small">Follow @haxeflixel</a><script>!function (d, s, id){var js, fjs = d.getElementsByTagName (s)[0];if (!d.getElementById (id)){js = d.createElement (s);js.id = id;js.src = "//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore (js, fjs);}} (document, "script", "twitter-wjs");</script></div><div class="footer-powered-by"><p>HaxeFlixel is powered by</p><a href="http://haxe.org"><img src="http://www.haxeflixel.com/images/haxe.svg" alt="Haxe" title="Haxe"/></a>+<a href="http://openfl.org"><img class="openfl-footer-logo" src="http://www.haxeflixel.com//images/openfl.svg" alt="OpenFL" title="OpenFL"/></a>+<a href="http://flixel.org"><img class="flixel-footer-logo" src="http://www.haxeflixel.com//images/flixel.svg" alt="Flixel" title="Flixel"/></a></div></div></div></footer>    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script></body></html>